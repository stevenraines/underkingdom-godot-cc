class_name MapSerializer
extends RefCounted

## MapSerializer - Handles map state serialization
##
## Serializes/deserializes map tiles, chunks, and metadata for all visited maps.

const FarmingSystemClass = preload("res://systems/farming_system.gd")


## Serialize all loaded maps
static func serialize_maps() -> Dictionary:
	var maps_data = {}

	# Save all loaded maps (visited dungeons, overworld)
	for map_id in MapManager.loaded_maps:
		var map = MapManager.loaded_maps[map_id]
		if not map:
			continue

		# For chunk-based maps (overworld), only save if it's the current map
		# (we can only save currently loaded chunks)
		if map.chunk_based:
			if map == MapManager.current_map:
				maps_data[map.map_id] = {
					"width": map.width,
					"height": map.height,
					"chunk_based": true,
					"chunks": ChunkManager.save_chunks()
				}
		else:
			# For non-chunked maps (dungeons), save all tiles for ALL visited floors
			var tiles_data = []

			# Save all tiles
			for y in range(map.height):
				for x in range(map.width):
					var tile = map.get_tile(Vector2i(x, y))
					tiles_data.append({
						"tile_type": tile.tile_type,
						"walkable": tile.walkable,
						"transparent": tile.transparent,
						"ascii_char": tile.ascii_char,
						"harvestable_resource_id": tile.harvestable_resource_id,
						"is_open": tile.is_open,
						"is_locked": tile.is_locked,
						"lock_id": tile.lock_id,
						"lock_level": tile.lock_level
					})

			maps_data[map.map_id] = {
				"width": map.width,
				"height": map.height,
				"chunk_based": false,
				"tiles": tiles_data,
				"metadata": map.metadata  # Save metadata (contains entity states)
			}

	return maps_data


## Deserialize maps (restore all saved maps into cache)
static func deserialize_maps(maps_data: Dictionary, current_map_id: String) -> void:
	# Restore ALL saved maps into MapManager.loaded_maps cache
	for map_id in maps_data:
		var map_data = maps_data[map_id]

		# Get the map from cache (it should already be generated by transition_to_map)
		# If it's not the current map, we need to generate it first
		var map: GameMap = null
		if map_id == current_map_id:
			map = MapManager.current_map
		elif map_id in MapManager.loaded_maps:
			map = MapManager.loaded_maps[map_id]
		else:
			# Generate the map so we can restore its state
			map = MapManager.get_or_generate_map(map_id, GameManager.world_seed)

		if not map:
			continue

		# For chunk-based maps, load chunks from save (only for current map)
		if map_data.get("chunk_based", false):
			if map == MapManager.current_map:
				var chunks_data = map_data.get("chunks", [])
				ChunkManager.load_chunks(chunks_data)
				print("MapSerializer: Loaded %d chunks for %s" % [chunks_data.size(), map_id])
			continue

		# For non-chunked maps (dungeons), restore tiles
		var tiles_data = map_data.tiles
		var idx = 0
		for y in range(map.height):
			for x in range(map.width):
				if idx >= tiles_data.size():
					break

				var tile_data = tiles_data[idx]
				var tile = map.get_tile(Vector2i(x, y))

				# Update tile properties from saved data
				tile.tile_type = tile_data.tile_type
				tile.walkable = tile_data.walkable
				tile.transparent = tile_data.transparent
				tile.ascii_char = tile_data.ascii_char
				tile.harvestable_resource_id = tile_data.harvestable_resource_id
				tile.is_open = tile_data.get("is_open", false)
				tile.is_locked = tile_data.get("is_locked", false)
				tile.lock_id = tile_data.get("lock_id", "")
				tile.lock_level = tile_data.get("lock_level", 1)

				idx += 1

		# Restore metadata (contains entity states for this map)
		if map_data.has("metadata"):
			map.metadata = map_data.metadata.duplicate(true)

		print("MapSerializer: Restored tiles for %s" % map_id)


## Serialize harvest system state (renewable resources and harvest progress)
static func serialize_harvest() -> Dictionary:
	return {
		"renewable_resources": HarvestSystem.serialize_renewable_resources(),
		"harvest_progress": HarvestSystem.serialize_harvest_progress()
	}


## Deserialize harvest system state
static func deserialize_harvest(harvest_data: Dictionary) -> void:
	# Restore renewable resources
	if harvest_data.has("renewable_resources"):
		HarvestSystem.deserialize_renewable_resources(harvest_data.renewable_resources)

	# Restore harvest progress
	if harvest_data.has("harvest_progress"):
		HarvestSystem.deserialize_harvest_progress(harvest_data.harvest_progress)

	print("MapSerializer: Harvest state deserialized")


## Serialize farming system state (crops and tilled soil)
static func serialize_farming() -> Dictionary:
	return FarmingSystemClass.serialize()


## Deserialize farming system state
static func deserialize_farming(farming_data: Dictionary) -> void:
	FarmingSystemClass.deserialize(farming_data)
	print("MapSerializer: Farming state deserialized")
